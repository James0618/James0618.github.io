<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-08-19T15:51:15+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">James’ HomePage</title><subtitle>这是一个初学博客的博主</subtitle><author><name>true</name></author><entry><title type="html">1 搭建实验环境</title><link href="http://localhost:4000/2019/08/19/1-%E6%90%AD%E5%BB%BA%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83.html" rel="alternate" type="text/html" title="1 搭建实验环境" /><published>2019-08-19T00:00:00+08:00</published><updated>2019-08-19T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/19/1%20%E6%90%AD%E5%BB%BA%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83</id><content type="html" xml:base="http://localhost:4000/2019/08/19/1-%E6%90%AD%E5%BB%BA%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83.html">&lt;h1 id=&quot;搭建实验环境&quot;&gt;搭建实验环境&lt;/h1&gt;

&lt;p&gt;  本章将会介绍如何对机械臂进行编程控制，实现的具体任务简单来说是控制机械臂的末端到达目标位姿。要实现这一目标我们需要完成以下几部分内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;搭建实验所用到的环境&lt;/li&gt;
  &lt;li&gt;使用OpenCv + Python利用颜色识别获取目标位姿&lt;/li&gt;
  &lt;li&gt;使用moveit! + Python控制机械臂到达制定位姿&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  在本章中使用到的实验环境包括一个UR5机械臂的仿真模型，一个黑色的盒子作为桌子以及桌子上的一个绿色小方块，除此之外还需要一个相机作为传感器加入到Gazebo仿真模型中；在识别部分，使用OpenCv中的模块对相机获取到的图像进行处理，通过颜色设置合适的阈值获得方块的位置，进而通过发布节点发布机械臂的目标位姿；在机械臂控制部分中通过订阅节点获取识别模块提供的目标位姿，使用moveit!编程在moveit!的规划场景中添加障碍物并进行轨迹规划，最后执行规划以实现控制Gazebo仿真模型中的UR5机械臂。&lt;/p&gt;

&lt;p&gt;  在搭建实验环境这一步骤中总共分为三个部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;下载并编译UR5机械臂的仿真模型&lt;/li&gt;
  &lt;li&gt;在Gazebo的世界模型中添加桌子及方块&lt;/li&gt;
  &lt;li&gt;在Gazebo中使用camera插件并进行调试&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ur5机械臂模型&quot;&gt;UR5机械臂模型&lt;/h2&gt;

&lt;p&gt;  首先是UR5的机械臂仿真模型，如果你已经看过了手眼标定的部分，那此时你的计算机上应该已经存在&lt;code class=&quot;highlighter-rouge&quot;&gt;universal_robot&lt;/code&gt;这个文件夹了，如果没有则按照下面的程序进行下载并编译，具体过程不在这里重复叙述了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install ros-kinetic-moveit
sudo apt-get install ros-kinetic-gazebo-ros-pkgs ros-kinetic-gazebo-ros-control
sudo apt-get install ros-kinetic-industrial-core

cd ~/catkin_ws/src
git clone https://github.com/ros-industrial/universal_robot.git

cd ../
rosdep install --from-paths src --ignore-src --rosdistro kinetic
catkin_make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  完成之后将会在你的工作空间中出现一个&lt;code class=&quot;highlighter-rouge&quot;&gt;universal_robot&lt;/code&gt;文件夹，这个文件夹内的&lt;code class=&quot;highlighter-rouge&quot;&gt;ur_description&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;ur_gazebo&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5_moveit_config&lt;/code&gt;是本部分所需要的内容。其中&lt;code class=&quot;highlighter-rouge&quot;&gt;ur_description&lt;/code&gt;这个Package中有UR5机械臂的URDF描述文件，在&lt;code class=&quot;highlighter-rouge&quot;&gt;ur_gazebo&lt;/code&gt;这个Package中有UR5机械臂在Gazebo仿真模型中的驱动文件包括一些控制关节的定义等，在&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5_moveit_config&lt;/code&gt;中则是实现机械臂轨迹规划的一些关键配置。下面就让我们看看如何编写launch文件使用这些Package中我们需要的部分。&lt;/p&gt;

&lt;p&gt;  首先在工作空间下新建一个package，我们将它命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5_grasping&lt;/code&gt;好了，在新Package的CMakeLists.txt文件中添加这些Package作为依赖：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cv_bridge
  image_transport
  moveit_core
  moveit_ros_planning
  moveit_ros_planning_interface
  moveit_visual_tools
  roscpp
  rospy
  sensor_msgs
  std_msgs
  tf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  当然package.xml文件也做相应的更改，具体的可以查看附件中的文件进行参考学习。在&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5_grasping&lt;/code&gt;的文件夹中新建两个文件夹：&lt;code class=&quot;highlighter-rouge&quot;&gt;launch&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;scripts&lt;/code&gt;，分别用来存放启动节点的launch文件和用来实现功能的Python文件。之后在launch文件夹下新建一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5_grasping.launch&lt;/code&gt;的文件用来启动节点。&lt;/p&gt;

&lt;p&gt;  这个launch文件需要实现的功能是启动UR5机械臂在Gazebo中的仿真模型和用于轨迹规划的moveit!模块，分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;ur_gazebo&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5.launch&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5_moveit_config&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5_moveit_planning_execution.launch&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;moveit_rviz.launch&lt;/code&gt;文件：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;launch&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;include&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;file=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find ur_gazebo)/launch/ur5_with_table_and_camera.launch&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;include&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;file=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find ur5_moveit_config)/launch/ur5_moveit_planning_execution.launch&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;arg&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sim&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/include&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;include&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;file=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find ur5_moveit_config)/launch/moveit_rviz.launch&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;arg&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;config&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/include&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/launch&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5_moveit_planning_execution.launch&lt;/code&gt;时需要将参数&lt;code class=&quot;highlighter-rouge&quot;&gt;sim&lt;/code&gt;设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;以代表我们是在仿真环境中进行驱动的，在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;moveit_rviz.launch&lt;/code&gt;时将参数&lt;code class=&quot;highlighter-rouge&quot;&gt;config&lt;/code&gt;设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;可以在打开RViz时直接使用配置好的界面。注意到我们并没有调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5.launch&lt;/code&gt;这个文件，这是因为我们需要对他进行修改，为了避免对原来的文件造成影响因此新建了一个launch文件。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../19/RViz界面.png&quot; width=&quot;45%&quot; height=&quot;45%&quot; /&gt;
  &lt;img src=&quot;../19/Gazebo界面.png&quot; width=&quot;45%&quot; height=&quot;45%&quot; /&gt;
&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt; 图1  RViz示意图 &amp;amp; Gazebo示意图 &lt;/div&gt;
&lt;p&gt;  现在启动这个launch文件，将会出现Gazebo和RViz两个界面，在RViz中可以拖动机器人末端测试moveit!是否成功启动：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch ur5_grasping ur5_grasping.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  当然现在在你们的界面中还不会显示出桌子和相机，不要着急，接下来就让我们开始添加这些。但是在此之前需要说明一点，在启动时你会发现机器人的位姿是平躺在地面上的，和图中显示的不太一样。这是UR系列机器人默认的起始位姿，调整到这个位姿是为了放置机械臂遮挡住上方相机的视线，我们可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;/ur_description/urdf&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5.urdf.xacro&lt;/code&gt;文件中修改机器人的其实位姿，调整的参数是joint中&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;origin&amp;gt;&lt;/code&gt;里的rpy角度，在调整时可以使用下面的命令打开机械臂的RViz界面进行参考：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch ur_description view_ur5.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  调整时需耐心调试角度，可以使用下图中的可视化界面拖动滑轴测试合理的角度，当然也可以直接使用课程附件中已经调整好的模型：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../19/view模型.png&quot; width=&quot;85%&quot; height=&quot;85%&quot; /&gt;
&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt; 图2  view_ur5的界面 &lt;/div&gt;
&lt;h2 id=&quot;添加桌子和方块&quot;&gt;添加桌子和方块&lt;/h2&gt;

&lt;p&gt;  在&lt;code class=&quot;highlighter-rouge&quot;&gt;ur_gazebo&lt;/code&gt;文件夹下有启动UR5机械臂Gazebo仿真模型的launch文件，&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5.launch&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5_joint_limited.launch&lt;/code&gt;，而后者启动的机械臂模型是各个关节有限制角度的仿真模型，打开这个文件你会发现他不过是include了&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5.launch&lt;/code&gt;之后修改了参数而已：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;launch&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;arg&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;gui&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;default=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;doc=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Starts gazebo gui&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

  &lt;span class=&quot;nt&quot;&gt;&amp;lt;include&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;file=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find ur_gazebo)/launch/ur5.launch&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;arg&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;limited&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;arg&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;gui&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(arg gui)&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/include&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/launch&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  为了不影响原来的结构，我们新建一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5_with_table_and_camera.launch&lt;/code&gt;的launch文件，将&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5.launch&lt;/code&gt;中的内容复制过来后修改添加世界模型的部分，将他的&lt;code class=&quot;highlighter-rouge&quot;&gt;world_name&lt;/code&gt;参数的值修改为&lt;code class=&quot;highlighter-rouge&quot;&gt;$(find ur_gazebo)/worlds/tableObj.world&lt;/code&gt;，也就是我们课程附件中用于描述桌子和方块的世界模型，当然文件夹和对应的文件需要提前放置在这个Package里。&lt;/p&gt;

&lt;p&gt;  在&lt;code class=&quot;highlighter-rouge&quot;&gt;tableObj.world&lt;/code&gt;中首先引用了在&lt;code class=&quot;highlighter-rouge&quot;&gt;tableObj2.world&lt;/code&gt;中的世界设置，随后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;model&lt;/code&gt;标签添加了两个物体，分别是box代表的桌子和Gazebo模型库中的coke_can。至此在实验环境中添加桌子和方块的任务就已经完成了，在&lt;code class=&quot;highlighter-rouge&quot;&gt;tableObj.world&lt;/code&gt;中可以通过修改两个模型的&lt;code class=&quot;highlighter-rouge&quot;&gt;scale&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;pose&lt;/code&gt;两个标签来调整桌子或方块的尺寸和起始位置。为了试验是否成功添加，可以使用刚才的命令打开Gazebo的界面进行查看：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch ur5_grasping ur5_grasping.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  值得一提的是，很多人可能在打开Gazebo时遇到长时间黑屏的问题，这是由于Gazebo的模型需要从其服务器上在线下载，为了加快打开速度可以将模型包下载到本地并解压到&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.gazebo/models&lt;/code&gt;文件夹下，下载的方式网上有很多就不在这里详细说明了。&lt;/p&gt;

&lt;h2 id=&quot;添加camera插件&quot;&gt;添加Camera插件&lt;/h2&gt;

&lt;p&gt;  添加Camera插件其实非常简单，相机的模型和xacro文件在网上已经是满天飞了，我们只需要坐享天成就可以了！&lt;/p&gt;

&lt;p&gt;  首先将附件中的sensor文件夹复制到&lt;code class=&quot;highlighter-rouge&quot;&gt;ur_descrption&lt;/code&gt;的urdf文件夹下，之后再在其中新建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5_joint_limited_robot_with_camera.urdf.xacro&lt;/code&gt;文件，接下来将&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5_joint_limited_robot.urdf.xacro&lt;/code&gt;中的内容复制过来，再在其中添加下面这行程序即可：&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;xacro:include&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;filename=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$(find ur_description)/urdf/sensors/camera.urdf.xacro&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  这行命令的意义在于将sensor文件夹下的camera模型加载进来，而在这个模型文件中主要做了两件事情：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;搭建相机的外观模型和碰撞模型等&lt;/li&gt;
  &lt;li&gt;加入Gazebo中的相机插件，使相机能够发布接收到的图像信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  在&lt;code class=&quot;highlighter-rouge&quot;&gt;camera.gazebo.xacro&lt;/code&gt;中你可以通过修改插件的参数来修改相机发布图像信息的消息，也可以修改相机的其他参数。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;  至此，我们本章所需要的实验环境已经搭载完毕了，现在我们可以使用一条命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch ur5_grasping ur5_grasping.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  来启动我们的实验环境，我们可以使用它通过编程实现轨迹规划，颜色识别，最后实现控制仿真模型中的机械臂末端到达通过颜色识别获取到的方块所在位置。&lt;/p&gt;</content><author><name>James</name></author><category term="机械臂视觉结合" /><summary type="html">搭建实验环境</summary></entry><entry><title type="html">2 OpenCV颜色识别</title><link href="http://localhost:4000/2019/08/19/2-OpenCv%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB.html" rel="alternate" type="text/html" title="2 OpenCV颜色识别" /><published>2019-08-19T00:00:00+08:00</published><updated>2019-08-19T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/19/2%20OpenCv%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB</id><content type="html" xml:base="http://localhost:4000/2019/08/19/2-OpenCv%E9%A2%9C%E8%89%B2%E8%AF%86%E5%88%AB.html">&lt;h1 id=&quot;opencv颜色识别&quot;&gt;OpenCV颜色识别&lt;/h1&gt;

&lt;p&gt;  在机械臂抓取任务中，对物体进行识别是一件十分重要的事情，对物体进行识别的作用一是在于获取其位置以使机械臂末端到达该物体所在位置，二是获取其位姿以确定机械臂末端抓取装置的抓取位姿。&lt;/p&gt;

&lt;p&gt;  在本章中出于简化的目的，将机械臂的抓取任务改为控制机械臂末端到达指定位姿，如果想要实现抓取可以在本章学习的基础上进行拓展，一方面使用搭建环境中学到的内容添加抓取装置，另一方面在本小节学习的基础上增加基于深度学习的物体识别与计算抓取位姿的模块，再结合下一小节中的机械臂moveit!编程则可以实现全套的机械臂抓取任务。以下是物体识别和抓取姿态分析的常见API：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 物体识别
http://wiki.ros.org/object_recognition
https://github.com/tensorflow/models/tree/master/research/object_detection
# 抓取姿态
http://wiki.ros.org/agile_grasp
http://wiki.ros.org/moveit_simple_grasps
http://wiki.ros.org/graspit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  在本小节中我们将使用OpenCv和Python通过颜色进行阈值判断获取方块所在的位置，再通过订阅器和发布器实现与仿真环境的交互。在开始之前，我们最好梳理一下这个模块中需要哪些部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用于接收仿真环境发布的图像消息的接收器&lt;/li&gt;
  &lt;li&gt;用于对接收到的图像进行处理的回调函数&lt;/li&gt;
  &lt;li&gt;用于发布处理结果的发布器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  那么接下来就让我们开始进行颜色识别的编程实现吧！在&lt;code class=&quot;highlighter-rouge&quot;&gt;ur5_grasping&lt;/code&gt;的scripts文件夹下新建一个recognition.py，要想能够通过rosrun运行这个程序，我们还需要在终端中输入下面命令将这个程序变为可执行程序：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/caktin_ws/src/ur5_grasping/scripts
chmod +x *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  在程序的第一行要写上&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;c1&quot;&gt;#!/usr/bin/env python&lt;/span&gt;&lt;/code&gt;来声明这是一个python文件，接下来就是import我们需要的头文件：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;rospy&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;cv2&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;geometry_msgs.msg&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pose&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sensor_msgs.msg&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Image&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;cv_bridge&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CvBridge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CvBridgeError&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  这些头文件中sys是用来获取终端中输入的参数的；rospy是ROS使用python编程的最重要的api，它提供了发布器和接收器等一系列重要功能；cv2则是OpenCv在Python中的api；numpy则是在Python中用于数组操作的最常用api；cv_bridge是在ROS中使用OpenCv进行图像处理最重要的api，它提供了ROS中图像消息类型和OpenCv可以处理的图像类型之间的转换；而那两个msg的import则是在程序中需要使用的消息类型，Pose是用于描述机械臂末端位姿的，Image则是ROS中的图像消息，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;rosmsg show&lt;/code&gt;进行查看：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../19/Image消息.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
  &lt;img src=&quot;../19/Pose消息.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  接下来定义一个名为Recognition的类并编写初始化函数：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Recognition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'image_recongition'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;anonymous&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image_sub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Subscriber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'/camera/image_raw'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;can_pub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'/recognition/can'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location_pub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Publisher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'/recognition/location'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bridge&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CvBridge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose_goal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Pose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose_goal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose_goal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.707&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose_goal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose_goal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.707&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  在初始化函数中首先使用rospy初始化了一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;image_recognition&lt;/code&gt;的节点，接下来是订阅相机话题消息的订阅器，它的回调函数是self.callback，我们将会后面进行介绍；之后是两个发布器，分别用于发布处理后的图像信息和机械臂末端应当到达的目标位姿；接下来的&lt;code class=&quot;highlighter-rouge&quot;&gt;self.bridge = CvBridge()&lt;/code&gt;则声明了一个bridge实例，用于进行数据格式的转换；剩下的就是声明了一个Pose实例用来描述机械臂末端的目标位姿。&lt;/p&gt;

&lt;p&gt;  实际上，通过初始化函数，我们已经将这一模块的整体框架搭建好了，下面就是本模块最重要的回调函数了，所有的处理都在这里进行，下面就让我们来看一下如何编写这一回调函数。&lt;/p&gt;

&lt;p&gt;  最首要的事情就是使用cv_bridge将订阅器接收到的图像消息转换为cv_image：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;cv_image&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bridge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imgmsg_to_cv2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'bgr8'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CvBridgeError&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  之后为了通过颜色更轻松的进行识别，需要将原来的RGB颜色空间转换到HSV颜色空间上来，不了解HSV颜色空间的可以自行查阅相关资料，简单来讲就是把对颜色的描述从三原色的合成转换成了色调H、饱和度S和明度V的合成：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;# convert bgr image to hsv and find the can by threshold
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;hsv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cvtColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;COLOR_BGR2HSV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;low_green_can&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;upper_green_can&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inRange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hsv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;low_green_can&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;upper_green_can&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bitwise_and&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  之后在使用numpy array设置筛选的阈值将图像中绿色的部分筛选出来，其中mask表示对筛选出来的像素进行的标注，而res则表示将这些标注与原图像进行合成后的结果，应当是在一片漆黑的背景中有一团绿色的点，这就是通过颜色识别到的方块：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../19/res.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  接下来使用的程序是OpenCv中用于标记轮廓使用到的一系列函数，首先将只有方块的那张图像res转换到灰度空间上：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;# find the center of the can
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;imgray&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cvtColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;COLOR_BGR2GRAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thresh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imgray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contours&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hierarchy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;findContours&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thresh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RETR_TREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CHAIN_APPROX_SIMPLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;img_contour&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;drawContours&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv_image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contours&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;255&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  之后再次通过阈值提取到方块占据的像素区域，接下来使用寻找轮廓的函数获得在上一步中选中区域的轮廓contours，接下来使用drawContours在原图中标注轮廓：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../19/轮廓.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  最后一步，计算方块的中心点。在OpenCv的轮廓处理的程序中，可以生成轮廓包含区域的矩，这些矩被保存在一个字典中，我们可以通过一个中学就学过的式子计算这个区域的重心，也就是程序中的cx和cy：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;# compute the location of coke_can
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contours&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'m10'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'m00'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'m01'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'m00'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cv_image&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;800.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;90.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;# the real scale
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;800.0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;90.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.3&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# the real scale
&lt;/span&gt;        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose_goal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose_goal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose_goal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.125&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location_pub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;publish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose_goal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ZeroDivisionError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;IndexError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    	&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;can_pub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;publish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bridge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cv2_to_imgmsg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;img_contour&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'bgr8'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CvBridgeError&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  接下来的一步通过图像和真实之间尺度变换来计算物块在仿真环境中的位置，也就是知道方块在图像中的像素坐标，然后将它映射到仿真环境中的坐标。在这个环节需要我们一些人工操作了，我是在上一小节搭建实验环境的时候改变了方块的位置来观察其在图像中坐标改变的像素数，借此推断出尺度变化的比例。在得到目标位姿后便可以发布修改过的&lt;code class=&quot;highlighter-rouge&quot;&gt;pose_goal&lt;/code&gt;消息了：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../19/echo.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  需要注意的是，由于在移动过程中机械臂会遮挡方块导致本模块无法检测到方块，这将会在获得区域以及计算其重心时报错，为了避免这样的情况干扰程序的运行，因此才需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;try - except&lt;/code&gt;进行异常处理。&lt;/p&gt;

&lt;p&gt;  最后，在调用这个模块的时候记得使用&lt;code class=&quot;highlighter-rouge&quot;&gt;rospy.spin()&lt;/code&gt;让其保持工作状态：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rec&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Recognition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;KeyboardInterrupt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Shutting Down!'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  以上就是OpenCv颜色识别的全部内容，最主要的是在实现这一功能时清晰的思路，知道自己在干什么知道需要什么，下一节我们就将顺着在这一节中发布的位姿消息实现机械臂控制的功能。&lt;/p&gt;</content><author><name>James</name></author><category term="机械臂视觉结合" /><summary type="html">OpenCV颜色识别</summary></entry><entry><title type="html">3 UR5机械臂控制</title><link href="http://localhost:4000/2019/08/19/3-UR5%E6%9C%BA%E6%A2%B0%E8%87%82%E6%8E%A7%E5%88%B6.html" rel="alternate" type="text/html" title="3 UR5机械臂控制" /><published>2019-08-19T00:00:00+08:00</published><updated>2019-08-19T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/19/3%20UR5%E6%9C%BA%E6%A2%B0%E8%87%82%E6%8E%A7%E5%88%B6</id><content type="html" xml:base="http://localhost:4000/2019/08/19/3-UR5%E6%9C%BA%E6%A2%B0%E8%87%82%E6%8E%A7%E5%88%B6.html">&lt;h1 id=&quot;ur5机械臂控制&quot;&gt;UR5机械臂控制&lt;/h1&gt;

&lt;p&gt;  在本小节中将会使用moveit!在Python的api进行编程，实现从颜色识别模块中获得目标位姿信息，进而控制机械臂到达目标位姿。为此，在程序中需要有这样几个部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;接收位姿信息的订阅器及其回调函数&lt;/li&gt;
  &lt;li&gt;在moveit!的规划场景中增加障碍物的函数&lt;/li&gt;
  &lt;li&gt;实现机械臂控制的函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  第一部分十分简单，我们将在最后进行介绍，接下来让我们学习其他部分程序的编写。首先import我们需要的头文件，其中moveit_commander就是在Python中进行moveit!编程最重要的api了：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#!/usr/bin/env python
&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;moveit_commander&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;moveit_msgs.msg&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;geometry_msgs.msg&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  声明一个名为Grasping的类，在它的初始化函数中需要初始化一个名为ur5_grasping的节点；之后创建的是规划场景的一个实例，其后的休眠&lt;code class=&quot;highlighter-rouge&quot;&gt;rospy.sleep(1)&lt;/code&gt;一定不能丢掉！初始化需要一定时间，否则将不能成功的添加障碍物；接着就是创建了move_group的一个实例，紧接着需要设置他的一些参数，其中最主要的是后两个参数，将replanning设置为True可以允许moveit!在轨迹规划失败时进行重规划，减少程序报错失效的可能；最后一步则是在规划场景中添加障碍物，如果成功则会在终端中显示&lt;code class=&quot;highlighter-rouge&quot;&gt;OK!&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Grasping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;moveit_commander&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roscpp_initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'ur5_grasping'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;anonymous&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moveit_commander&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PlanningSceneInterface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;box_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moveit_commander&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MoveGroupCommander&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'manipulator'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_goal_joint_tolerance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_max_acceleration_scaling_factor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_max_velocity_scaling_factor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;allow_replanning&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_planning_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'OK!'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Failed!'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  那么接下来就让我们看看是如何在规划场景中添加障碍物的。首先介绍一下这个障碍物，在没有添加障碍的情况下，机械臂的轨迹规划是完全自由的，为了实现一个简单的移动，轨迹规划的结果甚至有可能绕一个巨大的圈来实现你的目标，在这样的过程中就有可能与环境中的其他物体比如地面等发生碰撞。在这种情况下我们就需要在moveit!的规划场景中添加合适的障碍物，在进行轨迹规划的时候也会选择一条合适的轨迹以保证机械臂不会与环境中的物体发生碰撞。&lt;/p&gt;

&lt;p&gt;  在moveit!的官方文档中有一个十分复杂的例程，我们选取其中需要的部分来实现我们的功能，更加深入的内容可以前往官网进行学习：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://docs.ros.org/kinetic/api/moveit_tutorials/html/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  我们从例程中选择两个函数，其中一个函数是&lt;code class=&quot;highlighter-rouge&quot;&gt;is_ok&lt;/code&gt;。它是用来检测对场景的改变，比如添加物体或者让物体附着于某一关节的操作是否完成，在原例程中还有一个将物体附着与其他关节的函数，&lt;code class=&quot;highlighter-rouge&quot;&gt;is_ok&lt;/code&gt;通过传入的参数巧妙地同时完成了这一任务：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is_ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;box_is_known&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;box_is_attached&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;box_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;box_name&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_shutdown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# Test if the box is in attached objects
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;attached_objects&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_attached_objects&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;box_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;is_attached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attached_objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;# Test if the box is in the scene.
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# Note that attaching the box will remove it from known_objects
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;is_known&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;box_name&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_known_object_names&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;# Test if we are in the expected state
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;box_is_attached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_attached&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;box_is_known&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_known&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;# Sleep so that we give other threads time on the processor
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;seconds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  而另一函数则是&lt;code class=&quot;highlighter-rouge&quot;&gt;add_box&lt;/code&gt;，顾名思义他是用来在规划场景中添加物体的函数，首先它使用geometry_msg中的PoseStamped设置了盒子的位姿，并将它命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;table&lt;/code&gt;用来表示我们在Gazebo仿真模型中添加的桌子。仅仅添加桌子这一个障碍物是不够的，因为在规划中仍然可能会规划出错误的轨迹，导致机械臂和地面发生碰撞，因此还需要添加一个地面障碍物，方法步骤都和添加桌子是一样的。最终函数的返回值则是is_ok判断的结果，在调用时根据返回值便可以知道是否成功添加障碍物：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add_box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;box_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;box_name&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Add table
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;box_pose&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geometry_msgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PoseStamped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;box_pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;base_link&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;box_pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;box_pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.4&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;box_pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;box_pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;box_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;table&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;box_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;box_pose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Add floor
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;box_pose&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geometry_msgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PoseStamped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;box_pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frame_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;base_link&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;box_pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;orientation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;1.0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;box_pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;box_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;floor&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;scene&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;box_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;box_pose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;2.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

    &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;box_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;box_name&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;box_is_known&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  需要强调的是，这里的添加障碍物并不是真的在环境中放置了一个物体，执行完这些命令后你不会在Gazebo中发现任何的改变，但是在RViz界面中你将会看到刚刚被添加进来的桌子和地面，它起到的作用仅仅是用于moveit!在进行轨迹规划时能够避开真实环境或仿真中的物体，因此通常都将这里的障碍物设置的和真实或仿真环境中的障碍物大小一样。&lt;/p&gt;

&lt;p&gt;  在添加完障碍物后，我们就可以编写进行机械臂控制的函数了，在这里我们将实现两个功能：将机械臂归位和控制机械臂到达目标位姿。首先是让机械臂归位，在归位函数中使用之前初始化好的move_group实例对机械臂进行控制，设定目标姿态为之前预设的&lt;code class=&quot;highlighter-rouge&quot;&gt;home&lt;/code&gt;姿态，之后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;move_group.go()&lt;/code&gt;来执行规划，之后休眠一段时间等待机械臂达成目标：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;homing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_named_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'home'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  其次是控制机械臂到达目标位姿，首先使用move_group设定当前的机器人位姿作为起始状态，之后通过函数参数传递进来的目标位姿设定机械臂的目标位姿，接下来就是执行规划的轨迹、清楚目标位姿等后续操作：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;move_to_goal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pose_goal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_start_state_to_current_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_pose_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pose_goal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;plan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;go&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;        
        &lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;move_group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clear_pose_targets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  而在程序中实例化我们刚刚创建的类时，仅仅这些是不够的，因为我们还没有从上一个模块中获取目标位姿，因此需要创建一个接收器用来接收目标位姿的消息，与此同时还要声明一个全局变量用来从回调函数中获取目标位姿：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;goal&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;goal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
        
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;location_sub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rospy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Subscriber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'/recognition/location'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geometry_msgs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;demo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Grasping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;homing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move_to_goal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;goal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  至此我们的任务就全部完成了！现在就让我们试验一下吧，首先需要启动实验环境的仿真程序，接下来打开颜色识别的程序，然后可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;rostopic echo&lt;/code&gt;检查消息的内容来判断程序是否运行正常，最后就是打开抓取的程序完成我们的任务了！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch ur5_grasping ur5_grasping.launch
rosrun ur5_grasping recognition.py
rosrun ur5_grasping ur5_grasping.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../19/RViz最终结果.png&quot; width=&quot;45%&quot; height=&quot;45%&quot; /&gt;
  &lt;img src=&quot;../19/Gazebo最终结果.png&quot; width=&quot;45%&quot; height=&quot;45%&quot; /&gt;
&lt;/div&gt;</content><author><name>James</name></author><category term="机械臂视觉结合" /><summary type="html">UR5机械臂控制</summary></entry><entry><title type="html">ROS 外参标定</title><link href="http://localhost:4000/2019/08/10/ROS-%E5%A4%96%E5%8F%82%E6%A0%87%E5%AE%9A.html" rel="alternate" type="text/html" title="ROS 外参标定" /><published>2019-08-10T00:00:00+08:00</published><updated>2019-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/10/ROS%20%E5%A4%96%E5%8F%82%E6%A0%87%E5%AE%9A</id><content type="html" xml:base="http://localhost:4000/2019/08/10/ROS-%E5%A4%96%E5%8F%82%E6%A0%87%E5%AE%9A.html">&lt;h1 id=&quot;ros-外参标定&quot;&gt;ROS 外参标定&lt;/h1&gt;

&lt;p&gt;  在本小节中将会介绍如何使用ROS中的easy_handeye功能包进行基于UR5机械臂和Realsense相机进行手眼标定，为了实现这一目标我们需要进行如下准备：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;下载并安装手眼标定的依赖Package：aruco_ros，下载并打印对应的标定板；&lt;/li&gt;
  &lt;li&gt;下载并安装UR5在ROS下的驱动程序：universal_robot；&lt;/li&gt;
  &lt;li&gt;下载并安装手眼标定的Package：easy_handeye。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  下面就让我们开始本小节的学习吧！&lt;/p&gt;

&lt;h2 id=&quot;安装依赖packagearuco_ros&quot;&gt;安装依赖Package：aruco_ros&lt;/h2&gt;

&lt;p&gt;  首先安装手眼标定的依赖Package：aruco_ros，下载并打印对应的标定板。aruco库是由Univeristy of Cordoba开发的，它使用了AR标记能够快速提供基于三维位姿的实时估计，换句话说我们能够得到当前标定板的位姿，也就能够进行我们的标定过程。那么先让我们安装这一Package：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/catkin_ws/src
git clone https://github.com/pal-robotics/aruco_ros.git
cd ../
catkin_make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  先进入到我们ROS的工作空间，将代码克隆下来之后返回上一层目录进行编译和安装，至此这一个依赖Package已经安装完成，为了能够使用这一Package我们还需要下载并打印对应的标定板，可以使用这一网站进行下载：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://chev.me/arucogen/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  本小节中使用的标定板型号为&lt;code class=&quot;highlighter-rouge&quot;&gt;Dictionary: Original ArUco, Marker Id: 100, Marker Size: 100(mm)&lt;/code&gt;，最终结果如下图所示：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../10/aruco-100.svg&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  下载完成后就可以将其打印在硬纸板上之后想尽各种方法将它固定在机械臂末端上，由于末端和标定板之间的变换矩阵不必知道，因此只需要固定上就可以。&lt;/p&gt;

&lt;h2 id=&quot;驱动ur5机械臂&quot;&gt;驱动UR5机械臂&lt;/h2&gt;

&lt;p&gt;  接下来让我们安装UR5在ROS下的驱动程序：universal_robot。先进入到ROS的工作空间中将universal_robot的程序克隆下来，之后删除掉ur_driver文件夹，因为这一文件夹下的程序是针对UR5机械臂旧版驱动程序的，最新版本的驱动程序需要将ur_modern_driver中的程序克隆下来进行使用，记得一定要选择kinetic-devel分支下的程序。之后返回到上层目录中安装依赖Package后再进行编译，编译完成就可以进行使用了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install ros-kinetic-moveit
sudo apt-get install ros-kinetic-gazebo-ros-pkgs ros-kinetic-gazebo-ros-control
sudo apt-get install ros-kinetic-industrial-core

cd ~/catkin_ws/src
git clone https://github.com/ros-industrial/universal_robot.git
# 此处将ur_driver删除
cd universal_robot
git clone - b kinetic-devel https://github.com/ThomasTimm/ur_modern_driver

cd ~/catkin_ws
rosdep install --from-paths src --ignore-src --rosdistro kinetic
catkin_make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  有了这些Package作为基础我们现在就已经可以驱动UR5机械臂了，为此我们需要先对机械臂的网络进行设置。先使用网线将计算机和UR5机械臂的控制箱进行连接，之后在UR5机器人的示教器上打开网络设置选项，记录其静态网络地址以及子网掩码等信息，比如在我们使用的机械臂中，它的静态IP地址为&lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.1.10&lt;/code&gt;，子网掩码为&lt;code class=&quot;highlighter-rouge&quot;&gt;255.255.255.0&lt;/code&gt;，当然你也可以自己设置：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../10/示教器界面.jpg&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  记录好机械臂的网络信息后需要在计算机对以太网的网络转发进行设置，在Ubuntu16.04下打开有线连接的编辑，在ipv4设置中输入地址、子网掩码和网关，注意在地址处要选择一个和机械臂静态ip地址不一样的ip，比如我就选择了&lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.1.9&lt;/code&gt;，当然也可以选择11、12等等：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../10/网络配置1.png&quot; width=&quot;45%&quot; height=&quot;45%&quot; /&gt;
  &lt;img src=&quot;../10/网络配置2.png&quot; width=&quot;45%&quot; height=&quot;45%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  配置好了之后查看UR5示教器上的网络设置，如果显示网络成功连接则可以继续下一步了，接下来就运行机械臂的驱动程序和moveit规划程序来检查机械臂的配置是否正确：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch ur_modern_driver ur5_bringup.launch limited:=true robot_ip:=192.168.1.10 use_lowbandwidth_trajectory_follower:=true
roslaunch ur5_moveit_config ur5_moveit_planning_execution.launch limited:=true
roslaunch ur5_moveit_config moveit_rviz.launch config:=true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  按顺序执行后将会出现以下画面，在RViz中机械臂的位姿应当和真实的位姿是一模一样的，我们也可以拖动机械臂末端来实现规划，在执行后机械臂实体也将会移动到对应的位置：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../10/机械臂驱动成功.png&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;实现手眼标定&quot;&gt;实现手眼标定&lt;/h2&gt;

&lt;p&gt;  在完成机械臂的配置之后，就可以正式开始手眼标定了！首先还是安装手眼标定的程序easy_handeye，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/catkin_ws/src
git clone -b kinetic-devel https://github.com/lagadic/vision_visp.git
cd ..
catkin_make --pkg visp_hand2eye_calibration

cd ~/catkin_ws/src
git clone https://github.com/IFL-CAMP/easy_handeye
cd ..
catkin_make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  安装完成后就可以开始执行程序了，在easy_handeye的&lt;code class=&quot;highlighter-rouge&quot;&gt;/docs/example_launch&lt;/code&gt;文件夹下有一个样例launch文件，我们可以根据自己的硬件进行修改，首先在easy_handeye的launch文件夹下新建一个文件命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;test.launch&lt;/code&gt;，其内容如下所示：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../10/手眼标定程序.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  它是从样例文件修改得到的，在样例文件中我们首先修改了关于aruco marker的参数，由于我们下载的标定图的id是100大小为100mm，因此在这里将&lt;code class=&quot;highlighter-rouge&quot;&gt;marker_size&lt;/code&gt;改为&lt;code class=&quot;highlighter-rouge&quot;&gt;defaut=&quot;0.1&quot;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;marker_id&lt;/code&gt;改为&lt;code class=&quot;highlighter-rouge&quot;&gt;default=&quot;100&quot;&lt;/code&gt;。在相机的驱动文件处改成了realsense相机的驱动文件&lt;code class=&quot;highlighter-rouge&quot;&gt;rs_camera.launch&lt;/code&gt;，在启动aruco的节点处的两个参数建议改成相同的，值则为相机的坐标系名称，可以通过运行程序后使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rosrun rqt_tf_tree rqt_tf_tree
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;  进行查看，在这里我们的是&lt;code class=&quot;highlighter-rouge&quot;&gt;camera_color_optical_frame&lt;/code&gt;，两个参数&lt;code class=&quot;highlighter-rouge&quot;&gt;/camera_info&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;/image&lt;/code&gt;都改为我们相机对应的话题消息的名称。接下来是机械臂的配置，同样的填写机械臂的ip地址以及驱动程序名称。最后就是手眼标定程序的设置，在&lt;code class=&quot;highlighter-rouge&quot;&gt;tracking_base_frame&lt;/code&gt;参数处改成前面的坐标系，也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;camera_color_optical_frame&lt;/code&gt;，至此我们的launch文件就写好了，现在就启动一下试试吧。如果启动成功了将会出现三个界面，如果程序报错了最先应该查看机械臂是否开启，相机是否驱动正常。这三个界面分别是机械臂的RViz界面：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../10/机械臂驱动界面.png&quot; width=&quot;85%&quot; height=&quot;85%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  外参矩阵计算界面：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../10/外参矩阵计算界面.png&quot; width=&quot;85%&quot; height=&quot;85%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  手眼标定操作界面：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../10/手眼标定界面.png&quot; width=&quot;65%&quot; height=&quot;65%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;  有些人的外参矩阵计算画面中可能没有图像显示的界面，这个时候只需要在界面中添加插件后再将消息调整到&lt;code class=&quot;highlighter-rouge&quot;&gt;/aruco_tracker/result&lt;/code&gt;即可，这一图像显示界面十分重要，如果没有将会报错无法继续进行标定。现在准备工作已经做好，需要说明的是机械臂的初始位姿应该调整到一个合适的状态，因为在标定过程中需要移动机械臂来采集一共17组数据，如果初始位姿不合适将会有可能规划超时进而导致程序运行中断。&lt;/p&gt;

&lt;p&gt;  标定的过程十分的容易，首先在手眼标定操作界面点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Check starting pose&lt;/code&gt;，如果出现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Ready to start: click on next pose&lt;/code&gt;则说明当前机械臂的初始位姿是可行的，之后便重复以下的操作：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Next pose&lt;/code&gt; -&amp;gt; 点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Plan&lt;/code&gt; -&amp;gt; 绿色则可行，点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Execute&lt;/code&gt;/ 红色则不可行，点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Next Pose&lt;/code&gt; -&amp;gt; 在外参矩阵计算界面点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Take Sample&lt;/code&gt; -&amp;gt; 点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Next Pose&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  重复上述操作直到收集了17组数据，收集完数据后便可以在外参矩阵计算界面点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Compute&lt;/code&gt;，待计算完成后点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Save&lt;/code&gt;进行保存，如果发生报错保存失败也可以复制计算完成后出现在终端中的数据，二者的结果是一样的：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../10/手眼标定截图.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;  至此，基于UR5机械臂和Realsense D415相机的外参标定已经全部介绍完毕了，在获得了外参矩阵之后便可以通过ROS中提供的tf功能将相机所在的tf_tree与机械臂所在的tf_tree进行相连，之后进行点云标定就有了依据了。&lt;/p&gt;</content><author><name>James</name></author><category term="ROS手眼标定" /><summary type="html">ROS 外参标定</summary></entry><entry><title type="html">北大退档事件</title><link href="http://localhost:4000/2019/08/10/%E5%8C%97%E5%A4%A7%E9%80%80%E6%A1%A3%E4%BA%8B%E4%BB%B6.html" rel="alternate" type="text/html" title="北大退档事件" /><published>2019-08-10T00:00:00+08:00</published><updated>2019-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/10/%E5%8C%97%E5%A4%A7%E9%80%80%E6%A1%A3%E4%BA%8B%E4%BB%B6</id><content type="html" xml:base="http://localhost:4000/2019/08/10/%E5%8C%97%E5%A4%A7%E9%80%80%E6%A1%A3%E4%BA%8B%E4%BB%B6.html">&lt;h1 id=&quot;北大退档事件&quot;&gt;北大退档事件&lt;/h1&gt;

&lt;p&gt;  知道这件事情的我是出离愤怒的，在提档操作完全合理合法的前提下以臆想多次要求退档，这种操作完全超出我的理解范围。&lt;/p&gt;

&lt;p&gt;  我国是社会主义国家，我们最引以为傲的就是国家不遗余力的投资落后地区，教育、基础设施、工厂企业，为的就是实现共同富裕。高考按省份招生正是这一观点的延伸，确保落后地区能够有足够数量的学生在全国顶尖的高校接受教育，专项计划也一样，虽然其在实际执行中或许会存在舞弊的现象，但是于理于法这都是校方必须接受的规定。&lt;/p&gt;

&lt;p&gt;  提档后有权退档是高校选拔学生的自主权，但绝对不是高校以主观臆断拒绝专项计划学生的挡箭牌，更不用说北大作为全国高校中的翘楚，若其他高校纷纷效仿将会给落后地区或者贫困家庭带来什么样的影响，我国我党坚持的扶贫政策就这样从人民心目中高大的北京大学这里率先垮掉。&lt;/p&gt;

&lt;p&gt;  过去也曾想过高等教育改革，我作为一名省会城市重点高中的学生，拿着全省最优秀的资源，自然不曾想过在大山深处有多少贫困的学生挣扎着希望通过接受高等教育来改变自己的命运。成熟后的今天我知道，在中国没有彻底实现全体小康之前，像西方那样完全放开高校招生自主权的教育制度是完全不可能的，上了大学之后身边有很多同学是来自祖国各地的山村的，他们有些连电脑都不舍得买，拼拼凑凑弄出来一个廉价的台式机出来，而成绩却并不见得很差，我的一个直系学弟甚至是我们实验班的前三名。一个国家有一个国家的国情，如果都像北大这样以主观臆断拒绝已经提档的学生，那我国的贫富分化将会以坐火箭的速度向上飞去！&lt;/p&gt;

&lt;p&gt;  希望北京大学能给公众一个合理的交代，一个诚恳的道歉，而不是站在高处拿着所谓的高校自主权作为挡箭牌欺骗广大的韭菜们！&lt;/p&gt;</content><author><name>James</name></author><category term="随笔" /><summary type="html">北大退档事件</summary></entry><entry><title type="html">外参标定理论介绍</title><link href="http://localhost:4000/2019/08/10/%E5%A4%96%E5%8F%82%E6%A0%87%E5%AE%9A%E7%90%86%E8%AE%BA%E4%BB%8B%E7%BB%8D.html" rel="alternate" type="text/html" title="外参标定理论介绍" /><published>2019-08-10T00:00:00+08:00</published><updated>2019-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/10/%E5%A4%96%E5%8F%82%E6%A0%87%E5%AE%9A%E7%90%86%E8%AE%BA%E4%BB%8B%E7%BB%8D</id><content type="html" xml:base="http://localhost:4000/2019/08/10/%E5%A4%96%E5%8F%82%E6%A0%87%E5%AE%9A%E7%90%86%E8%AE%BA%E4%BB%8B%E7%BB%8D.html">&lt;h1 id=&quot;外参标定理论介绍&quot;&gt;外参标定理论介绍&lt;/h1&gt;

&lt;p&gt;  在机器人视觉应用中，手眼标定是一个至关重要的环节，没有手眼标定得到的外参矩阵就无法从相机获得到的图像信息有效的解析到物体的状态。手眼标定的目的就是为了获取机器人坐标系和相机坐标系之间的变换矩阵，也就是我们在内参标定理论中介绍的外参矩阵$[R \ \ t]$，在ROS中它可以提供相机坐标系和机器人坐标系之间的tf，将相机坐标系加入到机器人的tf_tree中。&lt;/p&gt;

&lt;p&gt;  在机器人手眼标定中共有两类方法，分类依据是相机固定的位置，将相机固定在机器人外的平台上时称为“眼在外”也就是“eye to hand”，而将相机固定在机器人的末端时则称为“眼在手”也就是“eye in hand”。&lt;/p&gt;

&lt;h2 id=&quot;手眼关系的数学描述&quot;&gt;手眼关系的数学描述&lt;/h2&gt;

&lt;p&gt;  本小节中我们将会介绍“眼在外”情况下的手眼标定问题，在之后的外参标定操作中也是基于“眼在外”这一情况进行实践的。在“眼在外”的情况中，我们的已知量为机器人各关节之间的变换矩阵以及机器人和底座之间的变换矩阵，由于已知标定板的型号，因此可以在观测时可以通过内参标定理论中介绍的方法计算得到相机到标定板之间的变换矩阵，而我们的目标也就是需要求解的未知量就是相机和机器人底座或者末端之间的变换矩阵，它的表示形式如下所示：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;T_{base1}^{end} T_{camera1}^{base1} T_{object}^{camera1} = T_{base2}^{end} T_{camera2}^{base2} T_{object}^{camera2} \\
(T_{base2}^{end})^{-1} T_{base1}^{end} T_{camera1}^{base1} = 
T_{camera2}^{base2} T_{camera2}^{object} (T_{object}^{camera1})^{-1}&lt;/script&gt;

&lt;p&gt;  让我来解释一下这个式子，在上式中的end表示机器人的末端抓取机构等，camera则表示相机，而object表示和机器人末端固连的标定板。上面的式子左右两边分别是两次测量，为了计算外参矩阵需要让机器人以及与其末端固连的标定板移动任意两个位姿，但是由于标定板是固定在机器人末端上的，因此无论移动多少个位姿机器人末端与标定板之间的变换矩阵是不变的，这也是两边的式子能够相等的基础。&lt;/p&gt;

&lt;p&gt;  之后将上边的等式转换一下形式就能写成下边的等式，注意到两次位姿移动中机器人底座和相机之间的变换矩阵$T_{camera}^{base}$应该是不变的，因此设它为$X$则可以将上式写成下面的形式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;AX=XB&lt;/script&gt;

&lt;p&gt;  可以证明无论采多少组数据，最终都可以写成上式的形式，因此求解外参矩阵的问题就转换为求解上面这方程中的$X$的问题了，这涉及到矩阵运算的相关知识在此就不赘述了，感兴趣的同学可以查看参考资料中给出的文章和链接进行学习，接下来我们将会详细介绍在ROS中如何使用Realsense D415相机和UR5机械臂进行手眼标定。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;[1] Shiu Y C, Ahmad S. Calibration of wrist-mounted robotic sensors by solving homogeneous transform equations of the form AX=XB[J]. IEEE Transactions on Robotics &amp;amp; Automation, 1989, 5(1):16-29.&lt;/p&gt;

&lt;p&gt;[2] http://math.loyola.edu/~mili/Calibration/index.html&lt;/p&gt;</content><author><name>James</name></author><category term="ROS手眼标定" /><summary type="html">外参标定理论介绍</summary></entry><entry><title type="html">ROS 内参标定</title><link href="http://localhost:4000/2019/08/09/ROS-%E5%86%85%E5%8F%82%E6%A0%87%E5%AE%9A.html" rel="alternate" type="text/html" title="ROS 内参标定" /><published>2019-08-09T00:00:00+08:00</published><updated>2019-08-09T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/09/ROS%20%E5%86%85%E5%8F%82%E6%A0%87%E5%AE%9A</id><content type="html" xml:base="http://localhost:4000/2019/08/09/ROS-%E5%86%85%E5%8F%82%E6%A0%87%E5%AE%9A.html">&lt;h1 id=&quot;ros-内参标定&quot;&gt;ROS 内参标定&lt;/h1&gt;

&lt;p&gt;​		  在这一小节中我们将会介绍如何使用Intel的Realsense D415相机的RGB部分进行内参的标定，除此之外也会使用笔记本电脑自带的摄像头进行标定以让每一位同学都能有机会进行操作。在给Realsense相机进行标定之前我们需要：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安装最新的Intel® RealSense™ SDK 2.0&lt;/li&gt;
  &lt;li&gt;安装Realsense与ROS通信的Package：realsense-ros&lt;/li&gt;
  &lt;li&gt;安装用于相机标定的Package：camera_calibration&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;安装依赖package&quot;&gt;安装依赖Package&lt;/h2&gt;

&lt;p&gt;​		  首先是安装最新的Intel® RealSense™ SDK 2.0，可以按照官方repo的&lt;a href=&quot;https://github.com/IntelRealSense/librealsense/blob/master/doc/distribution_linux.md#installing-the-packages&quot;&gt;文档&lt;/a&gt;进行安装。首先添加注册服务器的public key，之后检查代理配置，接下来就是将服务器加入到仓库列表中安装需要的四个package即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-key adv --keyserver keys.gnupg.net --recv-key C8B3A55A6F3EFCDE || sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key C8B3A55A6F3EFCDE
export http_proxy=&quot;http://&amp;lt;proxy&amp;gt;:&amp;lt;port&amp;gt;&quot;

sudo add-apt-repository &quot;deb http://realsense-hw-public.s3.amazonaws.com/Debian/apt-repo xenial main&quot; -u
sudo apt-get install librealsense2-dkms
sudo apt-get install librealsense2-utils
sudo apt-get install librealsense2-dev
sudo apt-get install librealsense2-dbg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		  如果需要更新一个功能包可以使用这两句命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
sudo apt-get upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		  接下来是安装Realsense与ROS通信的Package：realsense-ros。首先是进入到我们ROS的工作空间中将Package的代码下载下来并切换到对应的分支，之后就是编译和进行安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/catkin_ws/src
git clone https://github.com/IntelRealSense/realsense-ros.git
cd realsense-ros/
git checkout `git tag | sort -V | grep -P &quot;^\d+\.\d+\.\d+&quot; | tail -1`
cd ..
catkin_make clean
catkin_make -DCATKIN_ENABLE_TESTING=False -DCMAKE_BUILD_TYPE=Release
catkin_make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		  在安装之前需要确保依赖项已经安装过，在这一节课我们假设你已经学习过前面的课程并安装了必要的功能包。如果在编译过程中出错可以直接尝试使用下面这行命令获取缺失的功能包：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install ros-kinetic-缺失的功能包
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		  在编译好之后将Realsense相机通过USB线连接到电脑上后，可以使用这行命令检查是否安装成功并驱动相机：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch realsense2_camera rs_camera.launch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		  出现了下面的结果就说明安装成功了：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../09/相机驱动成功.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;​		  可用&lt;code class=&quot;highlighter-rouge&quot;&gt;rosrun rqt_image_view rqt_image_view&lt;/code&gt;选择&lt;code class=&quot;highlighter-rouge&quot;&gt;/camera/color/image_raw&lt;/code&gt;查看相机收到的图像信息。需要说明的是，相机获取图像信息是有一个帧率的，如果你的计算机无法处理高帧率的图像可以在launch文件中修改&lt;code class=&quot;highlighter-rouge&quot;&gt;color_fps&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;depth_fps&lt;/code&gt;等参数以防止出现溢出现象。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../09/相机图像.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;​		  最后一部分就是安装用于相机标定的Package：camera_calibration。这个Package的安装可以参考&lt;a href=&quot;http://wiki.ros.org/camera_calibration&quot;&gt;ROS Wiki&lt;/a&gt;的内容，首先将放在Github托管的程序下载在你的ROS工作空间里，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/catkin_ws/src
git clone -b kinetic https://github.com/ros-perception/image_pipeline
cd ../
catkin_make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		  或者也可以简单粗暴的使用apt-get进行安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install ros-kinetic-camera-calibration
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;realsense相机标定&quot;&gt;Realsense相机标定&lt;/h2&gt;

&lt;p&gt;​		  之后可以选择自己打印或者购买相机标定需要的标定板，本节课中我们使用的标定板型号为&lt;code class=&quot;highlighter-rouge&quot;&gt;GP150-12*9&lt;/code&gt;，有了标定板之后就可以开始进行相机标定了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;roslaunch realsense2_camera rs_camera.launch
rosrun camera_calibration cameracalibrator.py --size 11x8 --square 0.01 image:=/camera/color/image_raw camera:=/camera --no-service-check
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		  如上面的命令所示，首先需要启动我们的realsense相机，之后再调用相机标定的程序，之后的参数分别是标定板的型号、方块的边长、图像的话题和相机的前缀。需要注意的是我们购买的标定板显示的是12*9，但是在运行程序时输入的参数&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;指的是角点的数量，因此需要设置为11*8程序才能正常运行；除此之外，由于realsense相机并没有提供&lt;code class=&quot;highlighter-rouge&quot;&gt;/set_camera_info&lt;/code&gt;的服务，因此需要在参数中增加&lt;code class=&quot;highlighter-rouge&quot;&gt;--no-service-check&lt;/code&gt;，而且标定完成后的的结果只能保存而不能直接应用给相机。&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../09/相机标定程序示意图.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;​		  如上图所示，正确运行的程序可以看到很多被彩色点标注的角点，在标定时需要按照X方向、Y方向、垂直方向也就是远近和倾斜一共四个因素移动标定板，直到每一个横条都显示为绿色时就可以点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Calibrate&lt;/code&gt;计算内参矩阵了，计算需要耗时半分钟或者更久，结束之后点击&lt;code class=&quot;highlighter-rouge&quot;&gt;Save&lt;/code&gt;保存标定的结果就可以啦！标定的结果如下所示：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../09/标定矩阵结果.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;​		  在ost.yaml和ost.txt中记录了相机标定得到的内参矩阵，之后我们可以在编程中使用OpenCV或其他你喜欢的工具调用这一矩阵对获得的图像进行去畸变的操作，这部分内容我们就不在本课程中进行介绍了。接下来让我们简短的介绍如何使用笔记本电脑自带的相机进行标定。&lt;/p&gt;

&lt;h2 id=&quot;usb相机标定&quot;&gt;USB相机标定&lt;/h2&gt;

&lt;p&gt;​		  首先使用下面这行命令去安装usb相机在ROS下的驱动程序：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install ros-kinetic-usb-cam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		  通常不会出现什么问题，接下来就和之前的内容一样启动&lt;code class=&quot;highlighter-rouge&quot;&gt;camera_calibration&lt;/code&gt;程序，不过要根据usb_cam的话题消息进行一些改变：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rosrun camera_calibration cameracalibrator.py --size 11x8 --square 0.01 image:=/usb_cam/image_raw camera:=/usb_cam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		  之后便是一样的标定过程，需要说明的是标定计算结束并成功保存时将会出现下面的画面，保存的文件位置在&lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp/calibrationdata.tar.gz&lt;/code&gt;：&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
  &lt;img src=&quot;../09/标定结果保存终端示意图.png&quot; width=&quot;75%&quot; height=&quot;75%&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;​		  在本节课中我们介绍了Intel® RealSense D415相机的SDK和驱动程序的安装，ROS中相机标定程序camera_calibration的安装，演示了使用D415相机和笔记本电脑的usb相机进行内参标定的方法和注意事项。&lt;/p&gt;</content><author><name>James</name></author><category term="ROS手眼标定" /><summary type="html">ROS 内参标定</summary></entry><entry><title type="html">内参标定理论介绍</title><link href="http://localhost:4000/2019/08/09/%E5%86%85%E5%8F%82%E6%A0%87%E5%AE%9A%E7%90%86%E8%AE%BA%E4%BB%8B%E7%BB%8D.html" rel="alternate" type="text/html" title="内参标定理论介绍" /><published>2019-08-09T00:00:00+08:00</published><updated>2019-08-09T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/09/%E5%86%85%E5%8F%82%E6%A0%87%E5%AE%9A%E7%90%86%E8%AE%BA%E4%BB%8B%E7%BB%8D</id><content type="html" xml:base="http://localhost:4000/2019/08/09/%E5%86%85%E5%8F%82%E6%A0%87%E5%AE%9A%E7%90%86%E8%AE%BA%E4%BB%8B%E7%BB%8D.html">&lt;h1 id=&quot;内参标定理论介绍&quot;&gt;内参标定理论介绍&lt;/h1&gt;

&lt;p&gt;​		  在任何使用到相机的任务中，相机的内参标定都是一定要进行的，不过大多数购买到的相机都已经进行了提前的标定，不过为了能够更全面的掌握机械臂的手眼标定，我们还是需要掌握相机内参标定的方法。在这节课程中我们将会详细介绍张正友的经典论文&lt;code class=&quot;highlighter-rouge&quot;&gt;A Flexible New Technique fro Camera Calibration&lt;/code&gt;中提出的基于棋盘格的相机标定方法，在之后的课程中也会从实操角度介绍在ROS中如何对相机的内参进行标定。&lt;/p&gt;

&lt;h2 id=&quot;研究重心&quot;&gt;研究重心&lt;/h2&gt;

&lt;p&gt;​		  在学习一个新知识点之前首先需要明确这个问题的重心在哪里，使用的方法又是什么，这样才能够发现问题并有希望作出改进。在获取相机内参数的问题中，我们的核心在于使用已知的变量合理的表示内参数，并使用优化方法最终进行求解。在此之前我们先了解一下何为内参数：&lt;/p&gt;

&lt;p&gt;​		  在使用针孔相机获取三维世界的图像信息时需要经历这样几个过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先将三维世界中的一点$P=(X,Y,Z)$从世界坐标系通过刚体变换变换到相机所在的坐标系，需要的参数为旋转矩阵$R$和平移向量$t$，称为外参数；&lt;/li&gt;
  &lt;li&gt;获得了点$P$在相机坐标系下的坐标后，通过针孔相机的模型变换为成像平面上的点$p=(x,y)$；&lt;/li&gt;
  &lt;li&gt;将点$p$从成像平面通过缩放和平移变换变换到像素坐标系上的点$p=(u,\nu)$。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​         若将其转换为矩阵相乘的形式可以写成下面的式子：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
s
 \left(
 \begin{matrix}
   u \\
   \nu \\
   1 
  \end{matrix}
  \right)
 =
 \left[
 \begin{matrix}
   \alpha &amp; 0 &amp; c_x \\
   0 &amp; \beta &amp; c_y \\
   0 &amp; 0 &amp; 1
  \end{matrix}
  \right]
   \left[
 \begin{matrix}
   f &amp; 0 &amp; 0 &amp; 0 \\
   0 &amp; f &amp; 0 &amp; 0 \\
   0 &amp; 0 &amp; 1 &amp; 0
  \end{matrix}
  \right]
   \left[
 \begin{matrix}
   R &amp; t \\
   0^T &amp; 1 
  \end{matrix}
  \right]
   \left(
 \begin{matrix}
   X \\
   Y \\
   Z \\
   1
  \end{matrix}
  \right)
  \\
  =
   \left[
 \begin{matrix}
   f_x &amp; 0 &amp; c_x &amp; 0 \\
   0 &amp; f_y &amp; c_y &amp; 0 \\
   0 &amp; 0 &amp; 1 &amp; 0
  \end{matrix}
  \right]
     \left[
 \begin{matrix}
   R &amp; t \\
   0^T &amp; 1 
  \end{matrix}
  \right]
     \left(
 \begin{matrix}
   X \\
   Y \\
   Z \\
   1
  \end{matrix}
  \right) %]]&gt;&lt;/script&gt;

&lt;p&gt;​		  内参数被记做$A$，它表示将坐标系从成像平面变换到像素坐标系的变换矩阵：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
A=
 \left[
 \begin{matrix}
   f_x &amp; 0 &amp; c_x \\
   0 &amp; f_y &amp; c_y \\
   0 &amp; 0 &amp; 1
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;

&lt;p&gt;​		  而之前所说的外参数$R$和$t$则有上式中的这个矩阵进行表示：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\left[
 \begin{matrix}
   R &amp; t \\
   0^T &amp; 1 
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;

&lt;p&gt;​		  其中$f_{x}=\alpha f$，$f_{y}=\beta f$。而$\alpha,\beta$分别表示图像上单位距离内$x$方向和$y$方向的像素个数，因此$f_x,f_y$将相机的焦距变换为在$x,y$方向上的像素度量表示。除此以外，为了不失一般性通常还会在内参矩阵$A$上增加一个参数$\gamma$：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
A=
 \left[
 \begin{matrix}
   f_x &amp; \gamma &amp; c_x \\
   0 &amp; f_y &amp; c_y \\
   0 &amp; 0 &amp; 1
  \end{matrix}
  \right] %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;射影变换&quot;&gt;射影变换&lt;/h2&gt;

&lt;p&gt;​		  在张正友标定法中使用棋盘格标定板进行相机标定，标定板平面是三维世界中的一个平面$\Pi$，而标定板映射到的像素坐标系下的像又是另一个平面$\pi$，因此可以使用射影变换实现两个平面之间的映射，而这只需要知道两个平面的对应点坐标即可求得两个平面之间的射影变换矩阵$H$。&lt;/p&gt;

&lt;p&gt;​		  在进行相机标定的时候，我们的标定板都是特制的具有确定型号的，而在运行标定程序时也需要将所使用的标定板的参数输入进去，在执行程序时提取标定板上角点的坐标，而对应角点在像素坐标系下图像的坐标可以通过程序来获取，因此便可以得到两个平面之间的映射。其之间的关系和之前描述的一样，改写成下式：
&lt;script type=&quot;math/tex&quot;&gt;p=A[R|t]P&lt;/script&gt;
​		  其中$p$是像素坐标，$P$是棋盘坐标，因此由刚才对射影变换矩阵的叙述可以得到：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;H=A[R|t] \\
p=HP&lt;/script&gt;

&lt;p&gt;​		  设棋盘格所在平面为世界坐标系中$Z=0$的平面，这样棋盘格的任一角点P的世界坐标系为$(X,Y,0)$，则有：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;s
 \left(
 \begin{matrix}
   u \\
   \nu \\
   1 
  \end{matrix}
  \right)
 =
A[R\ \ t]
   \left(
 \begin{matrix}
   X \\
   Y \\
   0 \\
   1
  \end{matrix}
  \right)
  =
  A[r_1\ \ r_2 \ \ r_3 \ \ t]
   \left(
 \begin{matrix}
   X \\
   Y \\
   0 \\
   1
  \end{matrix}
  \right)
  =
  A[r_1 \ \ r_2 \ \ t]
   \left(
 \begin{matrix}
   X \\
   Y \\
   1
  \end{matrix}
  \right)
  \\
  H = \lambda A[r_1 \ \ r_2 \ \ t] = [h_1 \ \ h_2 \ \ h_3]&lt;/script&gt;

&lt;p&gt;​		  将射影变换矩阵转化为这个形式之后，便可以使用棋盘平面和成像平面上对应的点计算射影变换矩阵了。&lt;/p&gt;

&lt;h2 id=&quot;结果推导&quot;&gt;结果推导&lt;/h2&gt;

&lt;p&gt;  由刚才的式子我们可以得到以下的等式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\left\{
\begin{aligned}
r_1=\lambda A^{-1}h_1 \\
r_2=\lambda A^{-1}h_2 \\
t = \lambda A^{-1}h_3
\end{aligned}
\right.&lt;/script&gt;

&lt;p&gt;  而旋转矩阵$R$是正交矩阵，因此具有以下性质。也就是其列向量之间的内积为0，而每个列向量的模均为1：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;r_1^T r_2=0 \\
||r_1||=||r_2||=1&lt;/script&gt;

&lt;p&gt;​		  至此，我们得到了在内参标定中非常重要的等式，它是对应与一个射影变换矩阵的约束式，它仅仅表示一对相对应的图像所表示的射影变换矩阵，而在实际操作中往往会取多对图像来计算射影变换矩阵：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{cases}
h_1^T(A^{-1})^TA^{-1}h_2 = 0\\
h_1^T(A^{-1})^TA^{-1}h_1 = h_2^T(A^{-1})^TA^{-1}h_2 = 1
\end{cases}&lt;/script&gt;

&lt;p&gt;​		  现在让我们把上式中间那部分矩阵$(A^{-1})^TA^{-1}$改写一下，改写成下面这个矩阵，具体的推导太过于复杂不在这里介绍，感兴趣的可以翻看本节课资料中的论文原件进行研读：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
B=(A^{-1})^TA^{-1}=
\left[
 \begin{matrix}
   B_{11} &amp; B_{12} &amp; B_{13} \\
   B_{21} &amp; B_{22} &amp; B_{23} \\
   B_{31} &amp; B_{32} &amp; B_{33}
  \end{matrix}
\right]
=
\left[
 \begin{matrix}
   \frac{1}{\alpha ^2} &amp; -\frac{\gamma}{\alpha^2\beta} &amp; \frac{v_0\gamma-u_0\beta}{\alpha^2\beta} \\
   -\frac{\gamma}{\alpha^2\beta} &amp; \frac{\gamma^2}{\alpha^2\beta^2}+\frac{1}{\beta^2} &amp; -\frac{\gamma(v_0\gamma-u_0\beta)}{\alpha^2\beta^2}-\frac{v_0}{\beta^2} \\
   \frac{v_0\gamma-u_0\beta}{\alpha^2\beta} &amp; -\frac{\gamma(v_0\gamma-u_0\beta)}{\alpha^2\beta^2}-\frac{v_0}{\beta^2} &amp; \frac{(v_0\gamma-u_0\beta)^2}{\alpha^2\beta^2}+\frac{v_0}{\beta^2}+1
  \end{matrix}
\right] %]]&gt;&lt;/script&gt;

&lt;p&gt;​		  可以看到这个矩阵是一个对称矩阵，因此其仅具有6个未知量，可以将其写成更为紧凑的格式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;b=[B_{11},B_{12},B_{22},B_{13},B_{23},B_{33}]&lt;/script&gt;

&lt;p&gt;​		  接下来就应该结合刚才的约束方程来推导得到射影变换矩阵的表达形式了，令$h_i$为矩阵$H$的第$i$个行向量即$h_i=[h_{i1}, h_{i2}, h_{i3}]^T$，则结合之前式子有：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;h_i(A^{-1})^TA^{-1}h_j = h_iBh_j=v_{ij}^Tb&lt;/script&gt;

&lt;p&gt;其中$v_{ij}=[h_{i1}h_{j1},h_{i1}h_{j2}+h_{i2}h_{j1},h_{i2}h_{j2},h_{i3}h_{j1}+h_{i1}h_{j3},h_{i3}h_{j2}+h_{i2}h_{j3},h_{i3}h_{j3}]$&lt;/p&gt;

&lt;p&gt;​		  因此可以将约束方程改写为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{cases}
h_1^T(A^{-1})^TA^{-1}h_2 = 0\\
h_1^T(A^{-1})^TA^{-1}h_1 = h_2^T(A^{-1})^TA^{-1}h_2 = 1
\end{cases}
\Rightarrow
\begin{cases}
v_{22}^Tb = 0\\
v_{11}b=v_{12}b
\end{cases}&lt;/script&gt;

&lt;p&gt;​		  写成矩阵形式有：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\left[
\begin{matrix}
v_{12}^T \\
v_{11}-v_{22}
\end{matrix}
\right]
b
= Vb =0&lt;/script&gt;

&lt;p&gt;​		  这是仅仅使用一对图像计算射影变换矩阵时的方程，当采集到了多组图像时只需要将对应的$V$矩阵进行拼接即可。对于方程$Vb=0$的求解问题，最常见的方法就是最小二乘法，而在现代方法中常常使用$SVD$分解来求解这类问题，对SVD分解感兴趣的同学可以自行查找，这是一个十分常见的方法。在张正友论文的附录中给出了内参矩阵的计算方法：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{cases}
v_0 = (B_{12}B_{13}-B_{11}B_{23})/(B_{11}B_{22}-B_{12}^2) \\
u_0 = \gamma v_0/\beta - B_{13}\alpha^2/\lambda \\
\lambda = B_{33}-[B_{13}^2+v_0(B_{12}B_{13}-B_{11}B_{23})]/B_{11} \\
\alpha = \sqrt{\lambda / B_{11}} \\
\beta = \sqrt{\lambda B_{11} / (B_{11}B_{22}-B_{12}^2)} \\
\gamma = -B_{12}\alpha^2\beta / \lambda
\end{cases}&lt;/script&gt;

&lt;h2 id=&quot;消除畸变&quot;&gt;消除畸变&lt;/h2&gt;

&lt;p&gt;​		  在真实的相机中会因为光学透镜固有的问题而产生透视失真，通常可以将其分为枕形畸变、桶形畸变和线性畸变，其中枕形畸变和桶形畸变由于是径向对称的，因此也被称为径向畸变，使用下面的式子来表示径向畸变：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat{x} = x + x[k_1(x^2+y^2)+k_2(x^2+y^2)^2] \\
\hat{y} = y + y[k_1(x^2+y^2)+k_2(x^2+y^2)^2]&lt;/script&gt;

&lt;p&gt;​		  其中$k_1,k_2$表示径向畸变的系数，而且径向畸变的中心是相机的中心，则有：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat{\mu} = \mu + (\mu-\mu_0)[k_1(x^2+y^2)+k_2(x^2+y^2)^2] \\
\hat{\nu} = \nu + (\nu-\nu_0)[k_1(x^2+y^2)+k_2(x^2+y^2)^2]&lt;/script&gt;

&lt;p&gt;​		  继续将上式改写成矩阵形式，这个式子是从一幅图像上取点得到的，假设有$n$幅图像和$m$个图像点，那么便可以得到$2mn$个方程：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\left[
\begin{matrix}
(\mu-\mu_0)(x^2+y^2) &amp; (\mu-\mu_0)(x^2+y^2)^2 \\
(\nu-\nu_0)(x^2+y^2) &amp; (\nu-\nu_0)(x^2+y^2)^2
\end{matrix}
\right]
\left[
\begin{matrix}
k_1 \\
k_2
\end{matrix}
\right]
=
\left[
\begin{matrix}
\hat{\mu}-\mu \\
\hat{\nu}-\nu
\end{matrix}
\right] %]]&gt;&lt;/script&gt;

&lt;p&gt;​		  之后同样可以使用SVD对矩阵进行分解进而得到畸变参数$k=[k_1,k_2]^T$的最小二乘解，在得到畸变参数后便可以先对图像进行去畸变处理，之后在使用进行过去畸变的图像来估计相机的内参：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Dk=d \\
k = [k_1 \ \ k_2]^T = (D^TD)^{-1}D^Td&lt;/script&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;​		  在本节课中详细的介绍了张正友的内参相机标定法，使用这一方法可以使用棋盘格标定板快速的获得相机的内参数。这一方法已经十分成熟，在实际使用中并不需要我们手写代码去实现这一功能，在下一节课中我们将会学习如何使用ROS中的程序快速的实现相机的内参标定。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;[1] https://baike.baidu.com/item/镜头畸变/5120871&lt;/p&gt;

&lt;p&gt;[2] https://www.cnblogs.com/wangguchangqing/p/8335131.html&lt;/p&gt;

&lt;p&gt;[3] Zhang, Z. A flexible new technique for camera calibration[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 2000, 22(11):0-1334.&lt;/p&gt;</content><author><name>James</name></author><category term="ROS手眼标定" /><summary type="html">内参标定理论介绍</summary></entry><entry><title type="html">PyTorch 入门(2)</title><link href="http://localhost:4000/2019/08/05/PyTorch%E5%85%A5%E9%97%A8(2).html" rel="alternate" type="text/html" title="PyTorch 入门(2)" /><published>2019-08-05T00:00:00+08:00</published><updated>2019-08-05T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/05/PyTorch%E5%85%A5%E9%97%A8(2)</id><content type="html" xml:base="http://localhost:4000/2019/08/05/PyTorch%E5%85%A5%E9%97%A8(2).html">&lt;h1 id=&quot;pytorch入门2&quot;&gt;PyTorch入门(2)&lt;/h1&gt;

&lt;h2 id=&quot;分类任务&quot;&gt;分类任务&lt;/h2&gt;

&lt;p&gt;​		在分类任务中，需要对数据生成类别，我们通常不使用一个数字来表示类别比如1, 2, 3, 4, 5等，而是使用不同的神经元来表示类别，最终的输出类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;0 0 1&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;0 1 0&lt;/code&gt;等，而用到的$Loss Function$也多使用&lt;code class=&quot;highlighter-rouge&quot;&gt;CrossEntropyLoss()&lt;/code&gt;，也就是交叉熵，最后需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;torch.max(net(x), 1)[1]&lt;/code&gt;选出其中概率最大的作为选择的类别进行输出，其有两个维度&lt;code class=&quot;highlighter-rouge&quot;&gt;torch.max(net(x), 1)[0]&lt;/code&gt;则是最大的数值，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;[1]&lt;/code&gt;就是对应的神经元了。&lt;/p&gt;

&lt;p&gt;​		其他的部分和之前的都是一样的，在创建数据的时候使用了一个函数&lt;code class=&quot;highlighter-rouge&quot;&gt;torch.cat&lt;/code&gt;，这个函数把不同类别的数据放到了一起然后转换成想要的数据类型：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;n_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FloatTensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LongTensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		其参数dim是指拼接哪一个维度的数据，默认为0，上面的程序就将数据的第0维进行拼接，从两个[100, 2]的张量变成了一个[200, 2]的张量。&lt;/p&gt;

&lt;p&gt;​		接下来在莫烦的教程中还有一个没有用过的函数&lt;code class=&quot;highlighter-rouge&quot;&gt;plt.scatter()&lt;/code&gt;，之前使用matplotlib绘图都是直接plot大法好，这个高级的东西还是第一次见。它的用法介绍如下：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;matplotlib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pyplot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scatter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'b'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;marker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'o'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;norm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vmin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vmax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;alpha&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linewidths&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hold&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;参数&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;格式&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;x,y&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;形如shape(n, )数组&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;输入数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;s&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;标量或形如shape(n, )数组，默认：20&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;size in points^2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;c&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;色彩或颜色序列，可选&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C可以是一个RGB或者RGBA的二维行数组&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;marker&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MarkerStyle，可选&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;cmap&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Colormap可选，默认None&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;​		具体可以参照https://blog.csdn.net/qiu931110/article/details/68130199中介绍的属性。在教程中执行了以下命令：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scatter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()[:,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()[:,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pred_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'RdYlGn'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		这其中，前两个是需要画出来的数据两个维度的值，&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;则使用了一个小技巧，直接使用数据的标签当做色彩来对不同类别的数据进行区分，而不用手动判断类别后再进行绘制，而&lt;code class=&quot;highlighter-rouge&quot;&gt;lw&lt;/code&gt;则是指线的宽度$linewidths$。&lt;/p&gt;

&lt;h2 id=&quot;快速搭建法&quot;&gt;快速搭建法&lt;/h2&gt;

&lt;p&gt;​		可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;torch.nn.Sequential()&lt;/code&gt;直接替代先前的网络搭建部分，具体如下：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;net2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sequential&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Linear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReLU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Linear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		可以看到，激活函数在这里也被当做一层网络写在了函数里。&lt;/p&gt;

&lt;h2 id=&quot;保存--恢复网络&quot;&gt;保存 &amp;amp; 恢复网络&lt;/h2&gt;

&lt;p&gt;​		有两种方式来进行网络的保存和提取，一种是保存整个网络，另一种是只保存网络中的参数：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'net.pkl'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'net_params.pkl'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		前者占用的空间更大速度也更慢，区别体现在恢复网络的时候。保存整个网络的方法在恢复网络的时候无需新建一个网络，只需要：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'net.pkl'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		而只保存参数的方法则需要重建一个相同的网络再将参数放置到新建的网络中：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sequential&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Linear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReLU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Linear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load_state_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'net_params.pkl'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;批训练&quot;&gt;批训练&lt;/h2&gt;

&lt;p&gt;​		在PyTorch中可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;DataLoader&lt;/code&gt;进行简单的数据包装，经过包装后数据可以高效的迭代以进行训练，这一工具可以将自己的numpy array的数据转换成Tensor：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# 先转换成 torch 能识别的 Dataset
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch_dataset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TensorDataset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_tensor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target_tensor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# 把 dataset 放入 DataLoader
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DataLoader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dataset&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch_dataset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;# torch TensorDataset format
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;batch_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BATCH_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;# mini batch size
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;# 要不要打乱数据 (打乱比较好)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;num_workers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;# 多线程来读数据
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoch&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;batch_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Epoch: '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'| Step: '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'| batch x: '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;batch_x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'| batch y: '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch_y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		之后运行的结果如下所示：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
Epoch:0 | Step:0 | batch x:[6. 7. 2. 3. 1.] | batch y:[5. 4. 9. 8. 10.]
Epoch:0 | Step:1 | batch x:[9. 10. 4. 8. 5.] | batch y:[2. 1. 7. 3. 6.]
Epoch:1 | Step:0 | batch x:[3. 4. 2. 9. 10.] | batch y:[8. 7. 9. 2. 1.]
Epoch:1 | Step:1 | batch x:[1. 7. 8. 5. 6.] | batch y:[10. 4. 3. 6. 5.]
Epoch:2 | Step:0 | batch x:[3. 9. 2. 6. 7.] | batch y:[8. 2. 9. 5. 4.]
Epoch:2 | Step:1 | batch x:[10. 4. 8. 1. 5.] | batch y:[1. 7. 3. 10. 6.]
&quot;&quot;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;关于variable-和-tensor&quot;&gt;关于Variable 和 Tensor&lt;/h2&gt;

&lt;p&gt;​		在学习莫烦的教程中关于优化器的部分时，我注意到了在新版本PyTorch中有关Variable和Tensor之间关系的改变，不过在官方文档中没有发现什么。&lt;/p&gt;

&lt;p&gt;​		在教程的视频中对从TensorDataset里获取到的batch数据进行了转换为Variable的操作，解释道是因为只有Variable才能进行自动求导，官方文档也是这么说的。但事实上在教程的代码中取消了这一操作，而在Pycharm的Python控制台中查看变量的类型时，可以清晰地看到所有数据都是Tensor类型的。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# training
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoch&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPOCH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Epoch: '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l_his&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optimizers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;losses_his&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loss_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zero_grad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;backward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;l_his&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		询问了同学后得知Tensor变量只需要它的&lt;code class=&quot;highlighter-rouge&quot;&gt;require_grad&lt;/code&gt;属性是&lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;的就可以进行自动求导，经过查证果然如此！上述代码中的b_x和b_y的&lt;code class=&quot;highlighter-rouge&quot;&gt;require_grad&lt;/code&gt;属性是&lt;code class=&quot;highlighter-rouge&quot;&gt;False&lt;/code&gt;的，但是loss的&lt;code class=&quot;highlighter-rouge&quot;&gt;require_grad&lt;/code&gt;属性是&lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;的，这应该是在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;loss_func&lt;/code&gt;时为其加上的属性，这样便能够进行&lt;code class=&quot;highlighter-rouge&quot;&gt;backward()&lt;/code&gt;操作了！&lt;/p&gt;

&lt;p&gt;​		（所以事实证明Python Console是个好东西）&lt;/p&gt;</content><author><name>James</name></author><category term="PyTorch" /><summary type="html">PyTorch入门(2)</summary></entry><entry><title type="html">PyTorch 入门(1)</title><link href="http://localhost:4000/2019/08/02/PyTorch%E5%85%A5%E9%97%A8(1).html" rel="alternate" type="text/html" title="PyTorch 入门(1)" /><published>2019-08-02T00:00:00+08:00</published><updated>2019-08-02T00:00:00+08:00</updated><id>http://localhost:4000/2019/08/02/PyTorch%E5%85%A5%E9%97%A8(1)</id><content type="html" xml:base="http://localhost:4000/2019/08/02/PyTorch%E5%85%A5%E9%97%A8(1).html">&lt;h1 id=&quot;pytorch&quot;&gt;PyTorch&lt;/h1&gt;

&lt;h2 id=&quot;pytorch-中的求导&quot;&gt;Pytorch 中的求导&lt;/h2&gt;

&lt;p&gt;​		在Pytorch中的&lt;code class=&quot;highlighter-rouge&quot;&gt;backward()&lt;/code&gt;是用于计算图的求导的，首先变量有一个requires_grad参数，如果设置为$True$则需要进行求导，在求导过程中：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;backward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		是对其最后方设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;requires_grad=True&lt;/code&gt;的变量进行求导，例如下面这段程序，我们将从它及其它的变体来理解&lt;code class=&quot;highlighter-rouge&quot;&gt;backward()&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch.autograd&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Variable&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;tensor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FloatTensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Variable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requires_grad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Variable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;v_1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;v_2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v_1&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;v_2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;backward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;variable.grad: &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;variable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;grad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		上面这段程序是很好理解的，由于variable是最后方设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;requires_grad=True&lt;/code&gt;的参数，因此在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;v_2.backward()&lt;/code&gt;的时候就相当于对&lt;code class=&quot;highlighter-rouge&quot;&gt;variable&lt;/code&gt;求导，最终的结果如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;variable.grad: 
 tensor([12.])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		结果自然就是$3\times 4=12$了，但需要说明的是&lt;code class=&quot;highlighter-rouge&quot;&gt;backward()&lt;/code&gt;方法不支持对非标量进行求导，因此提供了一个$gradient$参数用骚操作实现对非标量求导。在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;out.backward(gradient)&lt;/code&gt;的时候，如果out不是一个标量，那么先构造一个标量的值：&lt;code class=&quot;highlighter-rouge&quot;&gt;L = torch.sum(z*gradient)&lt;/code&gt;，再计算关于L对各个叶子变量的梯度。因此&lt;code class=&quot;highlighter-rouge&quot;&gt;backward()&lt;/code&gt;在没有任何参数时相当于执行了&lt;code class=&quot;highlighter-rouge&quot;&gt;out.backward(gradient=torch.FloatTensor([1]))&lt;/code&gt;，也就是在结果上乘了一个1再求导，这也解释了为什么在&lt;code class=&quot;highlighter-rouge&quot;&gt;gradient=torch.FloatTensor([2])&lt;/code&gt;的时候结果会乘2。&lt;/p&gt;

&lt;p&gt;​		最后说明一下，&lt;code class=&quot;highlighter-rouge&quot;&gt;backward()&lt;/code&gt;的求导是真真切切的对变量求导，变量的平方的求导和变量的拷贝乘平方的结果是不一样的！&lt;/p&gt;

&lt;h2 id=&quot;建立神经网络&quot;&gt;建立神经网络&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unsqueeze(torch.linspace(-1, 1, 100), dim=1)&lt;/code&gt;：由于torch只能处理二维的数据，因此需要用这个操作增加一个维度（从0开始），比如这个语句就实现了从&lt;code class=&quot;highlighter-rouge&quot;&gt;torch.Size([100])&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;torch.Size([100, 1])&lt;/code&gt;的转换。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class Net(torch.nn.Module):&lt;/code&gt;：在定义网络的时候需要继承torch中神经网络的模型&lt;code class=&quot;highlighter-rouge&quot;&gt;torch.nn.Module&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;forward()&lt;/code&gt;：每一个网络中都会有这个方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​    在此叙述一下使用torch搭建网络所需要环节和步骤。首先是一个描述网络的类，其元素和方式在上面已经列出，其中在初始化函数使用&lt;code class=&quot;highlighter-rouge&quot;&gt;torch.nn&lt;/code&gt;的各种层来对网络进行描述，在&lt;code class=&quot;highlighter-rouge&quot;&gt;forward()&lt;/code&gt;中对网络的结构进行描述：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Net&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n_feature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n_hidden&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Net&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hidden&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Linear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n_feature&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n_hidden&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predict&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Linear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n_hidden&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hidden_out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;relu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hidden&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hidden_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		在完成了对网络的描述后需要进行训练或者说学习，在学习时需要构建损失函数和优化器，在构建优化器的时候需要将网络的参数传进去并设置学习率：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;optimizer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optim&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SGD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;loss_func&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MSELoss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		至于训练，则需要使用网络计算对应x的输出&lt;code class=&quot;highlighter-rouge&quot;&gt;prediction&lt;/code&gt;，之后使用预设的损失函数计算&lt;code class=&quot;highlighter-rouge&quot;&gt;loss&lt;/code&gt;，接下来首先将优化器的梯度置为0，这是因为每次优化结束梯度仍然会保持上一次的结果，然后对loss这个Variable变量进行&lt;code class=&quot;highlighter-rouge&quot;&gt;backward()&lt;/code&gt;操作，最后执行优化器的梯度下降操作：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;prediction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loss_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prediction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;optimizer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zero_grad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;backward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;optimizer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;​		&lt;code class=&quot;highlighter-rouge&quot;&gt;optimizer.zero_grad()&lt;/code&gt;这一步至关重要！一定不要忘记！&lt;/p&gt;</content><author><name>James</name></author><category term="PyTorch" /><summary type="html">PyTorch</summary></entry></feed>